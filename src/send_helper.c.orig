#include <peerlist.h>
#include <peer_server.h>
#include <packet.h>
#include <download.h>
#include <sha.h>

extern PeerServer psvr;

// send whohas
void send_whohas(){
    pkt_param_t param;

    PKT_PARAM_CLEAR(&param);
    param.socket = psvr.sock;
    param.p_count = -1;
    param.c = &psvr.getchunks;
    param.c_count = -1;

    param.type = PACKET_TYPE_WHOHAS;
    send_packet(&param);
}

void send_ihave(packet_t *pkt, int p_index) {
    int i, j, k, count;
    char *hexbuf;
    pkt_param_t param;

    count = GET_CHUNK_CNT(pkt);

    for (i = 0, k = 0; i < count; i++) {
        hexbuf = psvr.ihavechunks.chunks[k].sha1;
        GET_HASH(pkt, i, hexbuf);
        for (j = 0; j < psvr.haschunks.count; j++) {
            if(strcmp(hexbuf, psvr.haschunks.chunks[j].sha1) == 0){
                k ++ ;
                break;
            }
        }
    }

    // nothing to send
    if(!k) return;

    psvr.ihavechunks.count = k;

    // send IHAVE packet
    PKT_PARAM_CLEAR(&param);
    param.socket = psvr.sock;
    param.c = &psvr.ihavechunks;
    param.c_count = -1;

    //param.p = &peerlist;
    param.p_index = p_index;
    param.p_count = param.p_index == -1? -1: 1;


    param.type = PACKET_TYPE_IHAVE;
    send_packet(&param);
}

int parse_download(packet_t *pkt, int p_index){
    int i, count;
    int fail_flag = 0;

    char *hexbuf;

    download_t *dl;
    ChunkLine *cl;
    ll_Node *node;

    dl = & psvr.peerlist.peers[p_index].dl;

    if(ll_count(& dl->queue) != 0){
        ll_delete_allnodes(&dl->queue, delete_chunkline);
        init_linkedlist(& dl->queue);
    }

    count = GET_CHUNK_CNT(pkt);
    for (i = 0; i < count; i++) {
        cl = new_chunkline();
        if(! cl){
            fail_flag = 1;
            break;
        }
        node = new_ll_Node(cl);
        if(! node){
            fail_flag = 1;
            break;
        }
        ll_insert_last(&dl->queue, node);

        hexbuf = cl->sha1;
        GET_HASH(pkt, i, hexbuf);
    }

    if(fail_flag) {
        if(ll_count(&dl->queue) != 0){
            ll_delete_allnodes(&dl->queue, delete_chunkline);
            init_linkedlist(& dl->queue);
        }
        return -1;
    }

    return 0;
}

int send_get(int p_index, int getIndex){
    pkt_param_t param;

    psvr.getchunks.chunks[getIndex].state = fetching;

    // send GET packet
    PKT_PARAM_CLEAR(&param);

    param.socket = psvr.sock;
    param.c = &psvr.getchunks;
    param.c_index = getIndex;
    param.c_count = 1;

    //param.p = &peerlist;
    param.p_index = p_index;
    param.p_count = 1;

    param.type = PACKET_TYPE_GET;
    send_packet(&param);

    return 0;
}

/**
 * start download
 */
int start_download(Download *dl, int p_index, int get_index, const char *filename) {
    return dl_init(dl, p_index, get_index, filename);
}

/**
 * update download info when get a DATA
 */
int update_download(Download *dl, packet_t *pkt) {
    return dl_recv(dl, pkt);
}

/**
 * finish download
 */
int finish_download(Download *dl) {
    /*return dl_finish(dl);*/
    return 0;
}

/**
 * kill download
 */
int kill_download(Download *dl) {
    return 0;
}

/**
 * check if download is OK
 * @return 1 if finished, 0 if not.
 */
int is_download_finished(Download *dl) {
    return (dl->finished)? 1: 0 ;
}

int check_hash_succeed(Download *dl){
    uint8_t hash[SHA1_HASH_SIZE];
    char hash_str[SHA1_HASH_SIZE * 2 + 1];

    SHA1Context sc;
    SHA1Init(&sc);
    SHA1Update(&sc, dl->buffer, BT_CHUNK_SIZE);
    SHA1Final(&sc, hash);

    binary2hex(hash, SHA1_HASH_SIZE, hash_str);
    return ( strncmp(hash_str,
        psvr.getchunks.chunks[dl->get_index].sha1,
        SHA1_HASH_STR_SIZE) == 0
      )? 1 : 0;
}

int write_to_file(Download *dl){
    return 0;
}

/**
 * start the upload
 */
int start_upload(Upload *ul, int p_index, int has_index) {
    return ul_init(ul, p_index, has_index);
}

/**
 * update upload info when get an ACK
 */
int update_upload(Upload *ul, packet_t *pkt) {
    ul_handle_ack(ul, GET_ACK(pkt));
    return 0;
}

/**
 * check if upload is finished
 */
int is_upload_finished(Upload *ul) {
    return ul->finished;
}

/**
 * finish upload
 */
int finish_upload(Upload *ul) {
    return ul_deinit(ul);
}


